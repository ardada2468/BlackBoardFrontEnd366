'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.is_object = is_object;
exports.extend = extend;
exports.merge = merge;
exports.clone = clone;
exports.convert_from_camel_case = convert_from_camel_case;
exports.tabulate = tabulate;
// // if the variable is defined
var exists = exports.exists = function exists(what) {
	return typeof what !== 'undefined';
};

// used for JSON object type checking
var object_constructor = {}.constructor;

// detects a JSON object
function is_object(object) {
	return exists(object) && object !== null && object.constructor === object_constructor;
}

// extends the first object with 
/* istanbul ignore next: some weird transpiled code, not testable */
function extend() {
	for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
		objects[_key] = arguments[_key];
	}

	objects = objects.filter(function (x) {
		return exists(x);
	});

	if (objects.length === 0) {
		return;
	}

	if (objects.length === 1) {
		return objects[0];
	}

	var to = objects[0];
	var from = objects[1];

	if (objects.length > 2) {
		var last = objects.pop();
		var intermediary_result = extend.apply(this, objects);
		return extend(intermediary_result, last);
	}

	for (var _iterator = Object.keys(from), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
		var _ref;

		if (_isArray) {
			if (_i >= _iterator.length) break;
			_ref = _iterator[_i++];
		} else {
			_i = _iterator.next();
			if (_i.done) break;
			_ref = _i.value;
		}

		var key = _ref;

		if (is_object(from[key])) {
			if (!is_object(to[key])) {
				to[key] = {};
			}

			extend(to[key], from[key]);
		} else if (Array.isArray(from[key])) {
			if (!Array.isArray(to[key])) {
				to[key] = [];
			}

			to[key] = to[key].concat(clone(from[key]));
		} else {
			to[key] = from[key];
		}
	}

	return to;
}

function merge() {
	var parameters = Array.prototype.slice.call(arguments, 0);
	parameters.unshift({});
	return extend.apply(this, parameters);
}

function clone(object) {
	if (is_object(object)) {
		return merge({}, object);
	} else if (Array.isArray(object)) {
		return object.map(function (x) {
			return clone(x);
		});
	} else {
		return object;
	}
}

// converts all camelCased keys of an object to lodash style
function convert_from_camel_case(object) {
	for (var _iterator2 = Object.keys(object), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
		var _ref2;

		if (_isArray2) {
			if (_i2 >= _iterator2.length) break;
			_ref2 = _iterator2[_i2++];
		} else {
			_i2 = _iterator2.next();
			if (_i2.done) break;
			_ref2 = _i2.value;
		}

		var key = _ref2;

		if (/[A-Z]/.test(key)) {
			var lo_dashed_key = key.replace(/([A-Z])/g, function (match, group_1) {
				return '_' + group_1.toLowerCase();
			});

			if (!exists(object[lo_dashed_key])) {
				object[lo_dashed_key] = object[key];
				delete object[key];
			}
		}
	}

	return object;
}

function tabulate(text, tabs) {
	return text.split('\n').map(function (line) {
		if (line.trim() === '') {
			return '';
		}
		if (tabs < 0) {
			var i = -tabs;
			while (i > 0) {
				line = line.replace(/^\t/, '');
				i--;
			}
			return line;
		}
		return Array(tabs + 1).join('\t') + line;
	}).join('\n');
}
//# sourceMappingURL=helpers.js.map