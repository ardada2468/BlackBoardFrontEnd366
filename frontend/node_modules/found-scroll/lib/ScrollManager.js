"use strict";

exports.__esModule = true;
exports.default = void 0;

var _StateStorage = _interopRequireDefault(require("farce/StateStorage"));

var _HttpError = _interopRequireDefault(require("found/HttpError"));

var _PropTypes = require("found/PropTypes");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _scrollBehavior = _interopRequireDefault(require("scroll-behavior"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var STORAGE_NAMESPACE = '@@scroll';
var propTypes = {
  shouldUpdateScroll: _propTypes.default.func,
  createScrollBehavior: _propTypes.default.func.isRequired,
  renderArgs: _propTypes.default.shape({
    location: _propTypes.default.object.isRequired,
    router: _PropTypes.routerShape.isRequired,
    elements: _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.element, _propTypes.default.func])),
    error: _propTypes.default.instanceOf(_HttpError.default)
  }).isRequired,
  children: _propTypes.default.node
};
var defaultProps = {
  createScrollBehavior: function createScrollBehavior(config) {
    return new _scrollBehavior.default(config);
  }
};

var ScrollManager =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ScrollManager, _React$Component);

  function ScrollManager(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    _this.shouldUpdateScroll = function (prevRenderArgs, renderArgs) {
      var shouldUpdateScroll = _this.props.shouldUpdateScroll;

      if (!shouldUpdateScroll) {
        return true;
      } // Hack to allow access to ScrollBehavior internals (e.g. stateStorage).


      return shouldUpdateScroll.call(_this.scrollBehavior, prevRenderArgs, renderArgs);
    };

    var createScrollBehavior = props.createScrollBehavior,
        _renderArgs = props.renderArgs;
    var router = _renderArgs.router;
    _this.scrollBehavior = createScrollBehavior({
      addNavigationListener: router.addNavigationListener,
      stateStorage: new _StateStorage.default(router, STORAGE_NAMESPACE),
      getCurrentLocation: function getCurrentLocation() {
        return _this.props.renderArgs.location;
      },
      shouldUpdateScroll: _this.shouldUpdateScroll
    });
    _this.prevRenderArgs = null;
    return _this;
  }

  var _proto = ScrollManager.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.maybeUpdateScroll();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.maybeUpdateScroll();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.scrollBehavior.stop();
  };

  _proto.maybeUpdateScroll = function maybeUpdateScroll() {
    var renderArgs = this.props.renderArgs;
    var prevLocation = this.prevRenderArgs && this.prevRenderArgs.location;

    if (renderArgs.location === prevLocation || !(renderArgs.elements || renderArgs.error)) {
      // If the location hasn't actually changed, or if we're in a global
      // pending state, don't update the scroll position.
      return;
    }

    this.scrollBehavior.updateScroll(this.prevRenderArgs, renderArgs);
    this.prevRenderArgs = renderArgs;
  };

  _proto.render = function render() {
    return this.props.children;
  };

  return ScrollManager;
}(_react.default.Component);

ScrollManager.propTypes = propTypes;
ScrollManager.defaultProps = defaultProps;
var _default = ScrollManager;
exports.default = _default;
module.exports = exports.default;