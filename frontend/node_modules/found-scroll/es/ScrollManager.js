function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import StateStorage from 'farce/StateStorage';
import HttpError from 'found/HttpError';
import { routerShape } from 'found/PropTypes';
import PropTypes from 'prop-types';
import React from 'react';
import ScrollBehavior from 'scroll-behavior';
var STORAGE_NAMESPACE = '@@scroll';
var propTypes = {
  shouldUpdateScroll: PropTypes.func,
  createScrollBehavior: PropTypes.func.isRequired,
  renderArgs: PropTypes.shape({
    location: PropTypes.object.isRequired,
    router: routerShape.isRequired,
    elements: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.object, PropTypes.element, PropTypes.func])),
    error: PropTypes.instanceOf(HttpError)
  }).isRequired,
  children: PropTypes.node
};
var defaultProps = {
  createScrollBehavior: function createScrollBehavior(config) {
    return new ScrollBehavior(config);
  }
};

var ScrollManager =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ScrollManager, _React$Component);

  function ScrollManager(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    _this.shouldUpdateScroll = function (prevRenderArgs, renderArgs) {
      var shouldUpdateScroll = _this.props.shouldUpdateScroll;

      if (!shouldUpdateScroll) {
        return true;
      } // Hack to allow access to ScrollBehavior internals (e.g. stateStorage).


      return shouldUpdateScroll.call(_this.scrollBehavior, prevRenderArgs, renderArgs);
    };

    var createScrollBehavior = props.createScrollBehavior,
        _renderArgs = props.renderArgs;
    var router = _renderArgs.router;
    _this.scrollBehavior = createScrollBehavior({
      addNavigationListener: router.addNavigationListener,
      stateStorage: new StateStorage(router, STORAGE_NAMESPACE),
      getCurrentLocation: function getCurrentLocation() {
        return _this.props.renderArgs.location;
      },
      shouldUpdateScroll: _this.shouldUpdateScroll
    });
    _this.prevRenderArgs = null;
    return _this;
  }

  var _proto = ScrollManager.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.maybeUpdateScroll();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.maybeUpdateScroll();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.scrollBehavior.stop();
  };

  _proto.maybeUpdateScroll = function maybeUpdateScroll() {
    var renderArgs = this.props.renderArgs;
    var prevLocation = this.prevRenderArgs && this.prevRenderArgs.location;

    if (renderArgs.location === prevLocation || !(renderArgs.elements || renderArgs.error)) {
      // If the location hasn't actually changed, or if we're in a global
      // pending state, don't update the scroll position.
      return;
    }

    this.scrollBehavior.updateScroll(this.prevRenderArgs, renderArgs);
    this.prevRenderArgs = renderArgs;
  };

  _proto.render = function render() {
    return this.props.children;
  };

  return ScrollManager;
}(React.Component);

ScrollManager.propTypes = propTypes;
ScrollManager.defaultProps = defaultProps;
export default ScrollManager;