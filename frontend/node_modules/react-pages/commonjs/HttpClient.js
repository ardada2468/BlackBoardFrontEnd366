"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _superagent = _interopRequireDefault(require("superagent"));

var _helpers = require("./helpers");

var _cookies = require("./client/cookies");

var _HttpRequest = _interopRequireWildcard(require("./HttpRequest"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HTTP_METHODS = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options']; // This is an isomorphic (universal) HTTP client
// which works both on Node.js and in the web browser,
// and therefore can be used in Redux actions (for HTTP requests)

var HttpClient =
/*#__PURE__*/
function () {
  // `Set-Cookie` HTTP headers
  // (in case any cookies are set)
  // cookiesSetOnServer = new Set()
  // Constructs a new instance of Http client.
  // Optionally takes an Http Request as a reference to mimic
  // (in this case, cookies, to make authentication work on the server-side).
  function HttpClient() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HttpClient);

    _defineProperty(this, "cookiesSetOnServer", []);

    var proxy = options.proxy,
        headers = options.headers,
        cookies = options.cookies,
        authTokenHeader = options.authTokenHeader,
        onBeforeSend = options.onBeforeSend,
        catchToRetry = options.catchToRetry,
        getAuthToken = options.getAuthToken;
    var shouldParseJsonDates = options.parseDates !== false;
    var transformUrl = options.transformUrl || this.proxyUrl.bind(this); // Clone HTTP request cookies on the server-side
    // (to make authentication work)

    if (cookies) {
      this.server = true;
    }

    this.proxy = proxy; // "Get cookie value by name" helper (works both on client and server)

    var getCookie = this.server ? function (name) {
      // If this cookie was set dynamically then return it
      for (var _iterator = _this.cookiesSetOnServer, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var cookieRaw = _ref;

        if (cookieRaw.indexOf("".concat(name, "=")) === 0) {
          var _getCookieKeyAndValue = (0, _HttpRequest.getCookieKeyAndValue)(cookieRaw),
              _getCookieKeyAndValue2 = _slicedToArray(_getCookieKeyAndValue, 2),
              key = _getCookieKeyAndValue2[0],
              value = _getCookieKeyAndValue2[1];

          return value;
        }
      } // Return the original request cookie


      return cookies[name];
    } : _cookies.getCookie; // `superagent` doesn't save cookies by default on the server side.
    // Therefore calling `.agent()` explicitly to enable setting cookies.

    var agent = this.server ? _superagent["default"].agent() : _superagent["default"]; // Define HTTP methods on this `http` utility instance

    var _loop = function _loop() {
      if (_isArray2) {
        if (_i2 >= _iterator2.length) return "break";
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) return "break";
        _ref2 = _i2.value;
      }

      var method = _ref2;

      _this[method] = function (originalUrl, data) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        // `url` will be absolute for server-side
        var url = transformUrl(originalUrl, {
          server: _this.server
        }); // Is incremented on each retry

        var retryCount = -1; // Performs an HTTP request to the given `url`.
        // Can retry itself.

        var performHttpRequest = function performHttpRequest() {
          // Create Http request
          var request = new _HttpRequest["default"](method, url, data, {
            agent: agent,
            shouldParseJsonDates: shouldParseJsonDates,
            onResponseHeaders: options.onResponseHeaders,
            headers: _objectSpread({}, headers, {}, options.headers),
            onAddCookies: function onAddCookies(cookies) {
              if (_this.server) {
                // Cookies will be duplicated here
                // because `superagent.agent()` persists
                // `Set-Cookie`s between subsequent requests
                // (i.e. for the same `HttpClient` instance).
                // Therefore using a `Set` instead of an array.
                for (var _iterator3 = cookies, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                  var _ref3;

                  if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                  } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                  }

                  var cookie = _ref3;

                  // this.cookiesSetOnServer.add(cookie)
                  if (_this.cookiesSetOnServer.indexOf(cookie) < 0) {
                    _this.cookiesSetOnServer.push(cookie);
                  }
                }
              }
            }
          }); // Sets `Authorization: Bearer ${token}` in HTTP request header

          request.addAuthenticationToken(authTokenHeader, options.authentication, getAuthToken, getCookie, url, originalUrl); // On server side, user's cookies are attached to **all** relative "original" URLs
          // so `http.transformUrl(originalUrl)` must not transform relative URLs
          // into absolute URLs, otherwise user's cookies would be leaked to a third party.

          if (_this.server && isRelativeUrl(originalUrl)) {
            request.addCookies(cookies, _this.cookiesSetOnServer);
          } // Allows customizing HTTP requests.
          // (for example, setting some HTTP headers,
          //  or changing HTTP request `Content-Type`).
          // https://github.com/catamphetamine/react-website/issues/73


          if (onBeforeSend) {
            onBeforeSend(request.request, {
              url: url,
              originalUrl: originalUrl
            });
          } // File upload progress metering
          // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest


          if (options.progress) {
            request.progress(options.progress);
          }

          return request.send().then(function (response) {
            return response;
          }, function (error) {
            // `superagent` would have already output the error to console
            // console.error(error.stack)
            // Can optionally retry an HTTP request in case of an error
            // (e.g. if a JWT access token expired and has to be refreshed using a "refresh" token).
            // https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/
            if (catchToRetry) {
              retryCount++;
              return catchToRetry(error, retryCount, {
                getCookie: getCookie,
                http: _this
              }).then(performHttpRequest);
            } // HTTP request failed with an `error`


            throw error;
          });
        };

        return performHttpRequest();
      };
    };

    for (var _iterator2 = HTTP_METHODS, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      var _ret = _loop();

      if (_ret === "break") break;
    }
  } // Validates the requested URL,
  // and also prepends host and port to it on the server side.


  _createClass(HttpClient, [{
    key: "proxyUrl",
    value: function proxyUrl(url, _ref4) {
      var server = _ref4.server;

      // Prepend host and port on the server side
      if (this.proxy && server && isRelativeUrl(url)) {
        var protocol = this.proxy.secure ? 'https' : 'http';
        return "".concat(protocol, "://").concat(this.proxy.host, ":").concat(this.proxy.port || '80').concat(url);
      }

      return url;
    }
  }]);

  return HttpClient;
}();

exports["default"] = HttpClient;

function isRelativeUrl(url) {
  return (0, _helpers.starts_with)(url, '/') && !(0, _helpers.starts_with)(url, '//');
}
//# sourceMappingURL=HttpClient.js.map