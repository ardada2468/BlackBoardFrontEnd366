{"version":3,"sources":["../../../source/redux/middleware/asynchronous.js"],"names":["RESULT_ACTION_PROPERTY","ERROR_ACTION_PROPERTY","asynchronousMiddleware","httpClient","reduxEventNaming","server","onError","parseError","defaultParseError","DEFAULT_REDUX_EVENT_NAMING","dispatch","getState","next","action","promise","event","events","rest","length","Error","Request","Success","Failure","type","promised","http","then","console","error","Promise","resolve","reject","result","location","found","resolvedMatch","path","pathname","url","redirect","to","status","errorData","data","message"],"mappings":"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","sourcesContent":["import { exists, isObject } from '../../helpers'\r\nimport { getLocationUrl } from '../../location'\r\nimport { goto } from '../../router'\r\nimport { DEFAULT_REDUX_EVENT_NAMING } from '../naming'\r\n\r\nexport const RESULT_ACTION_PROPERTY = 'value'\r\nexport const ERROR_ACTION_PROPERTY = 'error'\r\n\r\n// Asynchronous middleware (e.g. for HTTP Ajax calls).\r\n//\r\n// Takes effect only if the `dispatch`ed action has\r\n// `promise` function and `events` (or `event`) property.\r\n//\r\n// `dispatch()` call will return a `Promise`.\r\n//\r\nexport default function asynchronousMiddleware(\r\n\thttpClient,\r\n\treduxEventNaming,\r\n\tserver,\r\n\tonError,\r\n\tparseError = defaultParseError\r\n) {\r\n\treduxEventNaming = reduxEventNaming || DEFAULT_REDUX_EVENT_NAMING\r\n\r\n\treturn ({ dispatch, getState }) => {\r\n\t\treturn next => action => {\r\n\t\t\tlet {\r\n\t\t\t\tpromise,\r\n\t\t\t\tevent,\r\n\t\t\t\tevents,\r\n\t\t\t\t...rest\r\n\t\t\t} = action\r\n\r\n\t\t\t// If the dispatched action doesn't have a `promise` function property then do nothing\r\n\t\t\tif (typeof promise !== 'function') {\r\n\t\t\t\treturn next(action)\r\n\t\t\t}\r\n\r\n\t\t\t// Generate the three event names automatically based on a base event name\r\n\t\t\tif (!events && typeof event === 'string') {\r\n\t\t\t\tevents = reduxEventNaming(event)\r\n\t\t\t}\r\n\r\n\t\t\t// Validate `events` property\r\n\t\t\tif (!events || events.length !== 3) {\r\n\t\t\t\tthrow new Error(`\"events\" property must be an array of 3 event names: e.g. ['pending', 'success', 'error']`)\r\n\t\t\t}\r\n\r\n\t\t\t// event names\r\n\t\t\tconst [ Request, Success, Failure ] = events\r\n\r\n\t\t\t// dispatch the `pending` event to the Redux store\r\n\t\t\tdispatch({ ...rest, type: Request })\r\n\r\n\t\t\t// Run the asychronous action (e.g. an HTTP request)\r\n\t\t\tconst promised = promise({ http: httpClient })\r\n\r\n\t\t\t// Validate that `promise()` actually returned a `Promise`\r\n\t\t\tif (!promised || typeof promised.then !== 'function') {\r\n\t\t\t\tconsole.error('Redux action\\'s \"promise\" function returned:', promised);\r\n\t\t\t\tthrow new Error('Redux action\\'s \"promise\" function must return a Promise.')\r\n\t\t\t}\r\n\r\n\t\t\t// Returning the result like this,\r\n\t\t\t// because if returned the `promised.then()` chain directly\r\n\t\t\t// then it wouldn't get detected as an \"Unhandled rejection\"\r\n\t\t\t// in case of an error.\r\n\t\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t\t// Don't `return` this promise\r\n\t\t\t\t// so that it detects it as an \"Unhandled rejection\"\r\n\t\t\t\t// in case of an error.\r\n\t\t\t\tpromised.then(\r\n\t\t\t\t\t// If the Promise resolved\r\n\t\t\t\t\t// (e.g. an HTTP request succeeded)\r\n\t\t\t\t\t(result) => {\r\n\t\t\t\t\t\t// Dispatch the `success` event to the Redux store\r\n\t\t\t\t\t\tdispatch({\r\n\t\t\t\t\t\t\t...rest,\r\n\t\t\t\t\t\t\ttype : Success,\r\n\t\t\t\t\t\t\t[RESULT_ACTION_PROPERTY] : result\r\n\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t// Returning the result like this,\r\n\t\t\t\t\t\t// because if returned the `promised.then()` chain directly\r\n\t\t\t\t\t\t// then it wouldn't get detected as an \"Unhandled rejection\"\r\n\t\t\t\t\t\t// in case of an error.\r\n\t\t\t\t\t\tresolve(result)\r\n\r\n\t\t\t\t\t\t// The Promise returned from `dispatch()` call\r\n\t\t\t\t\t\t// is resolved with the `promise` resolved value.\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t},\r\n\t\t\t\t\t// if the Http request failed\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// (Http status !== 20x\r\n\t\t\t\t\t//  or the Http response JSON object has an `error` field)\r\n\t\t\t\t\t(error) => {\r\n\t\t\t\t\t\t// Dispatch the `failure` event to the Redux store\r\n\t\t\t\t\t\tdispatch({\r\n\t\t\t\t\t\t\t...rest,\r\n\t\t\t\t\t\t\ttype : Failure,\r\n\t\t\t\t\t\t\t[ERROR_ACTION_PROPERTY] : parseError(error)\r\n\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t// The Promise returned from `dispatch()` call\r\n\t\t\t\t\t\t// is rejected with this error.\r\n\r\n\t\t\t\t\t\t// Also only checks `http` calls on client side\r\n\t\t\t\t\t\t// because on server side `http` calls can be\r\n\t\t\t\t\t\t// either part of `load` of part of `initialize`\r\n\t\t\t\t\t\t// which are already \"error handled\".\r\n\t\t\t\t\t\t// On the client side though, an `http` call\r\n\t\t\t\t\t\t// may be performed via some user input,\r\n\t\t\t\t\t\t// so it needs this separate case \"error handler\".\r\n\t\t\t\t\t\tif (!server && onError) {\r\n\t\t\t\t\t\t\tconst location = getState().found.resolvedMatch.location\r\n\t\t\t\t\t\t\t// Report the error\r\n\t\t\t\t\t\t\t// (for example, redirect to a login page\r\n\t\t\t\t\t\t\t//  if a JWT \"access token\" expired)\r\n\t\t\t\t\t\t\tonError(error, {\r\n\t\t\t\t\t\t\t\tpath: location.pathname,\r\n\t\t\t\t\t\t\t\turl: getLocationUrl(location),\r\n\t\t\t\t\t\t\t\t// Using `goto` instead of `redirect` here\r\n\t\t\t\t\t\t\t\t// because it's not part of `load`\r\n\t\t\t\t\t\t\t\t// and is therefore part of some kind of an HTTP request\r\n\t\t\t\t\t\t\t\t// triggered by user input (e.g. form submission)\r\n\t\t\t\t\t\t\t\t// which means it is convenient to be able to\r\n\t\t\t\t\t\t\t\t// go \"Back\" to the page on which the error originated.\r\n\t\t\t\t\t\t\t\tredirect: to => dispatch(goto(to)),\r\n\t\t\t\t\t\t\t\tdispatch,\r\n\t\t\t\t\t\t\t\tgetState,\r\n\t\t\t\t\t\t\t\tserver\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Returning the result (error) like this,\r\n\t\t\t\t\t\t// because if returned the `promised.then()` chain directly\r\n\t\t\t\t\t\t// then it wouldn't get detected as an \"Unhandled rejection\"\r\n\t\t\t\t\t\t// in case of an error.\r\n\t\t\t\t\t\treject(error)\r\n\r\n\t\t\t\t\t\t// Reduce client-side error reporting software (e.g. sentry.io)\r\n\t\t\t\t\t\t// noise for not-really-errors like \"Unauthenticated\" and \"Unauthorized\".\r\n\t\t\t\t\t\tif (error.status !== 401 && error.status !== 403) {\r\n\t\t\t\t\t\t\tthrow error\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Transform Javascript `Error` instance into a plain JSON object\r\n// because the meaning of the `error` action is different\r\n// from what `Error` class is: it should only carry info like\r\n// `status`, `message` and possible other values (e.g. `code`),\r\n// without any stack traces, line numbers, etc.\r\n// I.e. the `error` action should be a plain javascript object,\r\n// not an instance of an `Error` class, because it's Redux (stateless).\r\n//\r\n// Parses a `superagent` `Error` instance\r\n// into a plain JSON object for storing it in Redux state.\r\n// In case of an `application/json` HTTP response\r\n// the `error` instance ha `.data` JSON object property\r\n// which carries the `application/json` HTTP response data.\r\n//\r\nfunction defaultParseError(error)\r\n{\r\n\t// Copies JSON HTTP response entirely\r\n\tconst errorData = isObject(error.data) ? error.data : {}\r\n\r\n\t// Sets HTTP response `status` code\r\n\t// if `status` property wasn't present in JSON HTTP response.\r\n\tif (!exists(errorData.status)) {\r\n\t\terrorData.status = error.status\r\n\t}\r\n\r\n\t// Copies `message` from `Error` instance\r\n\t// if `message` property wasn't present in JSON HTTP response.\r\n\tif (!exists(errorData.message)) {\r\n\t\terrorData.message = error.message\r\n\t}\r\n\r\n\treturn errorData\r\n}"],"file":"asynchronous.js"}