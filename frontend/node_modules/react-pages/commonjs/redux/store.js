"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _createStore;

var _react = _interopRequireDefault(require("react"));

var _redux = require("redux");

var _logOnlyInProduction = require("redux-devtools-extension/logOnlyInProduction");

var _asynchronous = _interopRequireDefault(require("./middleware/asynchronous"));

var _router = _interopRequireDefault(require("./middleware/router"));

var _reducer = _interopRequireDefault(require("./preload/reducer"));

var _getData = _interopRequireDefault(require("./preload/getData"));

var _reducer2 = _interopRequireDefault(require("./translate/reducer"));

var _naming = require("./naming");

var _router2 = require("../router");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _createStore(settings, data, createHistoryProtocol, httpClient, options) {
  var reducers = settings.reducers,
      reduxMiddleware = settings.reduxMiddleware,
      reduxStoreEnhancers = settings.reduxStoreEnhancers,
      reduxEventNaming = settings.reduxEventNaming,
      http = settings.http,
      onError = settings.onError,
      getLocale = settings.getLocale,
      codeSplit = settings.codeSplit,
      meta = settings.meta,
      showLoadingInitially = settings.showLoadingInitially;
  var routes = settings.routes;
  var server = options.server,
      devtools = options.devtools,
      stats = options.stats,
      onBeforeNavigate = options.onBeforeNavigate,
      onNavigate = options.onNavigate,
      getCookie = options.getCookie; // `routes` will be converted.

  var convertedRoutes;

  var getConvertedRoutes = function getConvertedRoutes() {
    return convertedRoutes;
  }; // Add `load` data hook.


  var getData = (0, _getData["default"])(codeSplit, server, onError, getLocale, getConvertedRoutes, getCookie);

  if (Array.isArray(routes)) {
    // If there's an error on client side in `setUpAndRender()` then it's called again.
    // And in that case `getData` is set and this error will be thrown.
    // if (routes[0].getData) {
    // 	throw new Error('[react-pages] `getData` found on the root route')
    // }
    routes[0].getData = getData;
  } else {
    // Set `getData`.
    // If there's an error on client side in `setUpAndRender()` then it's called again.
    // And in that case `getData` is set and this error will be thrown.
    // if (routes.props.getData) {
    // 	throw new Error('[react-pages] `getData` found on the root route')
    // }
    routes = _react["default"].cloneElement(routes, {
      getData: getData
    }); // Convert `found` `<Route/>`s to a JSON structure.

    routes = (0, _router2.convertRoutes)(routes);
  }

  convertedRoutes = routes; // Redux middleware.
  // User may supply his own Redux middleware.

  var middleware = reduxMiddleware ? reduxMiddleware() : []; // Built-in middleware.

  middleware.push( // Asynchronous middleware (e.g. for HTTP Ajax calls).
  (0, _asynchronous["default"])(httpClient, reduxEventNaming, server, http.onError, http.getErrorData));

  if (!server) {
    middleware.push((0, _router["default"])(routes, codeSplit, onBeforeNavigate, onNavigate, stats, meta));
  } // Redux "store enhancers"


  var storeEnhancers = []; // User may supply his own Redux store enhancers.

  if (reduxStoreEnhancers) {
    storeEnhancers.push.apply(storeEnhancers, _toConsumableArray(reduxStoreEnhancers()));
  }

  storeEnhancers.push.apply(storeEnhancers, _toConsumableArray((0, _router2.createRouterStoreEnhancers)(routes, createHistoryProtocol, {
    basename: settings.basename
  }))); // Redux middleware are applied in reverse order.
  // (which is counter-intuitive)

  storeEnhancers.push(_redux.applyMiddleware.apply(void 0, _toConsumableArray(middleware))); // Create Redux store.

  var store = getStoreEnhancersComposer(server, devtools).apply(void 0, storeEnhancers)(_redux.createStore)(createReducer(reducers, showLoadingInitially), data); // On the client side, add `hotReload()` function to the `store`.
  // (could just add this function to `window` but adding it to the `store` fits more)

  if (!server) {
    // `hotReload` helper function gives the web application means to hot reload its Redux reducers
    store.hotReload = function (reducers) {
      return store.replaceReducer(createReducer(reducers, showLoadingInitially));
    };
  } // Initialize `found`.


  (0, _router2.initializeRouter)(store); // Return the Redux store

  return store;
}

function createReducer(reducers, showLoadingInitially) {
  // Check for reserved reducer names.
  for (var _iterator = RESERVED_REDUCER_NAMES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var reducerName = _ref;

    if (reducers[reducerName]) {
      throw new Error("\"".concat(reducerName, "\" reducer name is reserved."));
    }
  } // Check for `ReduxModule` autogenerated event names conflicts.


  (0, _naming.checkForAutogeneratedEventNameCollision)(reducers); // Clone the object because it will be modified.

  reducers = _objectSpread({}, reducers); // Add `found` reducer.

  reducers.found = _router2.foundReducer; // Add `load` status reducer.

  reducers.preload = (0, _reducer["default"])(showLoadingInitially); // // Add `@translate()` reducer.
  // reducers.translation = translateReducer
  // Create the compound reducer.

  return (0, _redux.combineReducers)(reducers);
}

function getStoreEnhancersComposer(server, devtools) {
  // Redux DevTools aren't used on the server side
  if (server) {
    return _redux.compose;
  } // Custom behaviour


  if (devtools && devtools.compose) {
    return devtools.compose;
  } // With custom options


  if (devtools && devtools.options) {
    return (0, _logOnlyInProduction.composeWithDevTools)(devtools.options);
  } // Without custom options


  return _logOnlyInProduction.composeWithDevTools;
}

var RESERVED_REDUCER_NAMES = ['found', 'location', 'preload', 'translation'];
//# sourceMappingURL=store.js.map