"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = renderOnServer;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _react = _interopRequireDefault(require("react"));

var _timer = _interopRequireDefault(require("../../timer"));

var _meta = require("../../meta/meta");

var _router = require("../../router");

var _createRouterElement = _interopRequireDefault(require("../../router/server/createRouterElement"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Returns a Promise resolving to { status, content, redirect }.
//
function renderOnServer(_x) {
  return _renderOnServer.apply(this, arguments);
} // One can set a `status` prop for a route
// to be returned as an Http response status code (404, etc)


function _renderOnServer() {
  _renderOnServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(_ref) {
    var store, codeSplit, defaultMeta, time, preloadTimer, renderArgs, _renderArgs, routes, elements, meta;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            store = _ref.store, codeSplit = _ref.codeSplit, defaultMeta = _ref.defaultMeta;
            // Routing only takes a couple of milliseconds
            // const routingTimer = timer()
            // Profiling
            time = {};
            preloadTimer = (0, _timer["default"])();
            _context.prev = 3;
            _context.next = 6;
            return (0, _router.matchRoutes)(store);

          case 6:
            renderArgs = _context.sent;
            _context.next = 14;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](3);

            if (!(_context.t0 instanceof _router.RedirectException)) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return", {
              redirect: _context.t0.location
            });

          case 13:
            throw _context.t0;

          case 14:
            time.load = preloadTimer(); // Gather `<title/>` and `<meta/>` tags for this route path

            _renderArgs = renderArgs, routes = _renderArgs.routes, elements = _renderArgs.elements; // Get `<meta/>` for the route.

            meta = codeSplit ? (0, _meta.getCodeSplitMeta)(routes, store.getState()) : (0, _meta.getComponentsMeta)(elements.filter(function (_) {
              return _;
            }).map(function (_) {
              return _.type;
            }), store.getState());
            meta = (0, _meta.mergeMeta)(meta);
            meta = _objectSpread({}, defaultMeta, {}, meta); // Return HTTP status code and the rendered page

            return _context.abrupt("return", {
              // Concatenated route `path` string.
              // E.g. "/user/:user_id/post/:post_id"
              route: getRoutePath(routes),
              status: getHttpResponseStatusCodeForTheRoute(routes),
              content: (0, _createRouterElement["default"])(renderArgs),
              meta: meta,
              containerProps: {
                store: store
              },
              time: time
            });

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 9]]);
  }));
  return _renderOnServer.apply(this, arguments);
}

function getHttpResponseStatusCodeForTheRoute(matchedRoutes) {
  return matchedRoutes.reduce(function (previous, current) {
    return current && current.status || previous && current.status;
  }, null);
} // Returns a complete `path` for matched route chain.
// E.g. returns "/user/:user_id/post/:post_id"
// for matched URL "/user/1/post/123?key=value".


function getRoutePath(routes) {
  return routes // Select routes having `path` React property set.
  .filter(function (route) {
    return route.path;
  }) // Trim leading and trailing slashes (`/`)
  // from each route `path` React property.
  .map(function (route) {
    return route.path.replace(/^\//, '').replace(/\/$/, '');
  }) // Join route `path`s with slashes (`/`).
  .join('/') || '/';
}
//# sourceMappingURL=render.js.map