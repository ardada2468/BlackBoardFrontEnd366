{"version":3,"sources":["../source/location.js"],"names":["getLocationUrl","location","options","basename","parseLocation","origin","pathname","search","hash","pathname_starts_at","indexOf","length","slice","search_index","hash_index","isSameLocationIgnoreHash","fromLocation","toLocation","shouldSkipPreloadForNavigation","action"],"mappings":"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","sourcesContent":["export function getLocationUrl(location, options = {})\r\n{\r\n\tif (typeof location === 'string') {\r\n\t\tif (options.basename) {\r\n\t\t\tlocation = parseLocation(location)\r\n\t\t} else {\r\n\t\t\treturn location\r\n\t\t}\r\n\t}\r\n\r\n\tconst origin   = location.origin || ''\r\n\tconst pathname = location.pathname\r\n\tconst search   = location.search || ''\r\n\tconst hash     = location.hash || ''\r\n\r\n\t// Append `basename` only to relative URLs\r\n\tconst basename = (!origin && options.basename) ? options.basename : ''\r\n\r\n\treturn `${origin}${basename}${pathname}${search}${hash}`\r\n}\r\n\r\n// Doesn't construct `query` though\r\nexport function parseLocation(location)\r\n{\r\n\tif (typeof location !== 'string') {\r\n\t\treturn location\r\n\t}\r\n\r\n\tlet origin\r\n\tlet pathname\r\n\r\n\tif (location === '') {\r\n\t\tpathname = '/'\r\n\t} else if (location[0] === '/') {\r\n\t\tpathname = location\r\n\t} else {\r\n\t\tconst pathname_starts_at = location.indexOf('/', location.indexOf('//') + '//'.length)\r\n\r\n\t\tif (pathname_starts_at > 0) {\r\n\t\t\torigin   = location.slice(0, pathname_starts_at)\r\n\t\t\tpathname = location.slice(pathname_starts_at)\r\n\t\t} else {\r\n\t\t\torigin   = location\r\n\t\t\tpathname = '/'\r\n\t\t}\r\n\t}\r\n\r\n\tlet search = ''\r\n\tlet hash = ''\r\n\r\n\tconst search_index = pathname.indexOf('?')\r\n\tif (search_index >= 0) {\r\n\t\tsearch   = pathname.slice(search_index)\r\n\t\tpathname = pathname.slice(0, search_index)\r\n\t}\r\n\r\n\tconst hash_index = search.indexOf('#')\r\n\tif (hash_index >= 0) {\r\n\t\thash   = search.slice(hash_index)\r\n\t\tsearch = search.slice(0, hash_index)\r\n\t}\r\n\r\n\treturn { origin, pathname, search, hash }\r\n}\r\n\r\nfunction isSameLocationIgnoreHash(fromLocation, toLocation) {\r\n\treturn toLocation.origin === fromLocation.origin &&\r\n\t\ttoLocation.pathname === fromLocation.pathname &&\r\n\t\ttoLocation.search === fromLocation.search\r\n}\r\n\r\n// A workaround for `found` router bug:\r\n// https://github.com/4Catalyzer/found/issues/239\r\n// Skip `load` and other stuff for anchor link navigation.\r\nexport function shouldSkipPreloadForNavigation(fromLocation, toLocation) {\r\n\tif (isSameLocationIgnoreHash(fromLocation, toLocation)) {\r\n\t\t// If a \"hash\" link has been clicked,\r\n\t\t// or if it's a Back/Forward navigation\r\n\t\t// then `load` should be skipped.\r\n\t\tif (toLocation.hash || toLocation.action === 'POP') {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n}"],"file":"location.js"}