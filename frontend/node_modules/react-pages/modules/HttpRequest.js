function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import parseDates from './parseDates';
import { isObject } from './helpers'; // Performs HTTP requests

var HttpRequest =
/*#__PURE__*/
function () {
  function HttpRequest(method, url, data, options) {
    _classCallCheck(this, HttpRequest);

    var agent = options.agent,
        headers = options.headers,
        shouldParseJsonDates = options.shouldParseJsonDates,
        onAddCookies = options.onAddCookies,
        onResponseHeaders = options.onResponseHeaders;
    this.onAddCookies = onAddCookies; // Create Http request.

    this.request = agent[method](url); // Attach data to the outgoing HTTP request

    if (data) {
      switch (method) {
        case 'get':
          this.request.query(data);
          break;

        case 'post':
        case 'put':
        case 'patch':
        case 'head':
        case 'options':
          if (hasBinaryData(data)) {
            addMultipartData(this.request, data);
          } else {
            this.request.send(data);
          }

          break;

        case 'delete':
          throw new Error("\"data\" supplied for HTTP DELETE request: ".concat(JSON.stringify(data)));

        default:
          throw new Error("Unknown HTTP method: ".concat(method));
      }
    } // Apply HTTP headers


    this.request.set(headers); // `true`/`false`

    this.shouldParseJsonDates = shouldParseJsonDates; // Can be used for examining HTTP response headers
    // (e.g. Amazon S3 file upload)

    this.onResponseHeaders = onResponseHeaders;
  } // Sets `Authorization: Bearer ${token}` in HTTP request header


  _createClass(HttpRequest, [{
    key: "addAuthenticationToken",
    value: function addAuthenticationToken(authTokenHeader, authentication, getAuthToken, getCookie, url, originalUrl) {
      var token;

      if (typeof authentication === 'string') {
        token = authentication;
      } else if (getAuthToken) {
        token = getAuthToken(getCookie, {
          url: url,
          originalUrl: originalUrl
        });
      }

      if (token && authentication !== false) {
        this.request.set(authTokenHeader || 'Authorization', "Bearer ".concat(token));
      }
    } // Server side only
    // (copies user authentication cookies to retain session specific data)

  }, {
    key: "addCookies",
    value: function addCookies(cookies, cookiesToAdd) {
      // Merge the initial HTTP request `cookies` and `cookiesToAdd` (a `Set`)
      if (cookiesToAdd.size > 0) {
        cookies = _objectSpread({}, cookies);

        for (var _iterator = cookiesToAdd, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var cookieRaw = _ref;

          var _getCookieKeyAndValue = getCookieKeyAndValue(cookieRaw),
              _getCookieKeyAndValue2 = _slicedToArray(_getCookieKeyAndValue, 2),
              key = _getCookieKeyAndValue2[0],
              value = _getCookieKeyAndValue2[1];

          cookies[key] = value;
        }
      }

      if (Object.keys(cookies).length > 0) {
        this.request.set('cookie', Object.keys(cookies).map(function (key) {
          return "".concat(key, "=").concat(cookies[key]);
        }).join(';'));
      }
    } // File upload progress metering
    // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest

  }, {
    key: "progress",
    value: function progress(_progress) {
      this.request.on('progress', function (event) {
        if (event.direction !== 'upload') {
          // Only interested in file upload progress metering
          return;
        }

        if (!event.lengthComputable) {
          // Unable to compute progress information since the total size is unknown
          return;
        }

        _progress(event.percent, event);
      });
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      return this.request.then(function (response) {
        if (_this.onResponseHeaders) {
          _this.onResponseHeaders(response.headers);
        } // (on the server)
        // If any cookies were set then track them (for later).
        // `response.headers['set-cookie']` is an array of `String`s.


        if (response.headers['set-cookie']) {
          _this.onAddCookies(response.headers['set-cookie']);
        } // If HTTP response status is "204 - No content"
        // (PUT, DELETE) then resolve with an empty result.


        if (response.statusCode !== 204) {
          return _this.getResponseData(response);
        }
      }, function (error) {
        // Infer additional `error` properties from the HTTP response.
        if (error.response) {
          _this.populateErrorDataFromResponse(error, error.response);
        }

        throw error;
      });
    }
  }, {
    key: "populateErrorDataFromResponse",
    value: function populateErrorDataFromResponse(error, response) {
      var responseData = this.getResponseData(response); // Set `error.status` to HTTP response status code

      error.status = response.statusCode;

      switch (response.type) {
        // Set error `data` from response body,
        case 'application/json': // http://jsonapi.org/

        case 'application/vnd.api+json':
          error.data = responseData; // Set the more meaningful message for the error (if available)

          if (error.data.message) {
            error.message = error.data.message;
          }

          break;
        // If the HTTP response was not a JSON object,
        // but rather a text or an HTML page,
        // then include that information in the `error`
        // for future reference (e.g. easier debugging).

        case 'text/plain':
          error.message = responseData;
          break;

        case 'text/html':
          error.html = responseData; // Recover the original error message (if any)

          if (response.headers['x-error-message']) {
            error.message = response.headers['x-error-message'];
          } // Recover the original error stack trace (if any)


          if (response.headers['x-error-stack-trace']) {
            error.stack = JSON.parse(response.headers['x-error-stack-trace']);
          }

          break;
      }
    }
  }, {
    key: "getResponseData",
    value: function getResponseData(response) {
      switch (response.type) {
        case 'application/json': // http://jsonapi.org/

        case 'application/vnd.api+json':
          if (this.shouldParseJsonDates) {
            return parseDates(response.body);
          }

          return response.body;
        // case 'text/plain':
        // case 'text/html':

        default:
          return response.text;
      }
    }
  }]);

  return HttpRequest;
}(); // Returns `[key, value]` from a raw cookie string


export { HttpRequest as default };
export function getCookieKeyAndValue(cookieRaw) {
  var semicolonIndex = cookieRaw.indexOf(';');

  if (semicolonIndex >= 0) {
    cookieRaw = cookieRaw.slice(0, semicolonIndex);
  }

  return cookieRaw.trim().split('=');
}

function addMultipartData(request, data) {
  for (var _i2 = 0, _Object$keys = Object.keys(data); _i2 < _Object$keys.length; _i2++) {
    var key = _Object$keys[_i2];
    var parameter = data[key]; // For an `<input type="file"/>` DOM element just take its `.files`

    if (typeof HTMLInputElement !== 'undefined' && parameter instanceof HTMLInputElement) {
      parameter = parameter.files;
    } // For a `FileList` parameter (e.g. `multiple` file upload),
    // iterate the `File`s in the `FileList`
    // and add them to the form data as a `[File]` array.


    if (typeof FileList !== 'undefined' && parameter instanceof FileList) {
      var i = 0;

      while (i < parameter.length) {
        request.attach(key, parameter[i]);
        i++;
      }
    } else if (typeof File !== 'undefined' && parameter instanceof File) {
      request.attach(key, parameter);
    } else {
      request.field(key, parameter);
    }
  }
}

function hasBinaryData(data) {
  if (!isObject(data)) {
    return false;
  }

  for (var _i3 = 0, _Object$keys2 = Object.keys(data); _i3 < _Object$keys2.length; _i3++) {
    var key = _Object$keys2[_i3];
    var parameter = data[key];

    if (typeof HTMLInputElement !== 'undefined' && parameter instanceof HTMLInputElement) {
      return true;
    }

    if (typeof FileList !== 'undefined' && parameter instanceof FileList) {
      return true;
    } // `File` is a subclass of `Blob`
    // https://developer.mozilla.org/en-US/docs/Web/API/Blob


    if (typeof Blob !== 'undefined' && parameter instanceof Blob) {
      return true;
    }
  }
}
//# sourceMappingURL=HttpRequest.js.map