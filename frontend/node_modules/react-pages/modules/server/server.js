import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import http from 'http';
import https from 'https';
import cookie from 'cookie';
import render from './render';
import renderError from './renderError';
import timer from '../timer';
import { getPreferredLocales } from './locale';
export default function server(settings, options) {
  if (options.initialize) {
    throw new Error('[react-pages] "initialize" server-side parameter function was removed. Use a root-level `load` instead.');
  }

  return (options.secure ? https : http).createServer(function (request, response) {
    // Render the page (and handle errors, if any)
    respondWithPage(request, response, settings, options)["catch"](function (error) {
      return respondWithError(error, response, options.printError);
    });
  });
} // Renders a webpage

function respondWithPage(_x, _x2, _x3, _x4) {
  return _respondWithPage.apply(this, arguments);
} // Renders a webpage.
// `headers`: `{ cookie, accept-language, host, user-agent }`.


function _respondWithPage() {
  _respondWithPage = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(request, response, settings, options) {
    var _ref, redirect, cookies, status, content, _iterator, _isArray, _i, _ref2, _cookie;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return renderPage(request.url, request.headers, settings, options);

          case 2:
            _ref = _context.sent;
            redirect = _ref.redirect;
            cookies = _ref.cookies;
            status = _ref.status;
            content = _ref.content;

            if (!redirect) {
              _context.next = 10;
              break;
            }

            response.writeHead(302, {
              Location: redirect
            });
            return _context.abrupt("return", response.end());

          case 10:
            _iterator = cookies, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 11:
            if (!_isArray) {
              _context.next = 17;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("break", 25);

          case 14:
            _ref2 = _iterator[_i++];
            _context.next = 21;
            break;

          case 17:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 20;
              break;
            }

            return _context.abrupt("break", 25);

          case 20:
            _ref2 = _i.value;

          case 21:
            _cookie = _ref2;
            response.setHeader('Set-Cookie', _cookie);

          case 23:
            _context.next = 11;
            break;

          case 25:
            // HTTP response status and "Content-Type"
            response.writeHead(status || 200, {
              'Content-Type': 'text/html'
            }); // Stream the rendered React page

            content.pipe(response);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _respondWithPage.apply(this, arguments);
}

export function renderPage(_x5, _x6, _x7, _x8) {
  return _renderPage.apply(this, arguments);
}

function _renderPage() {
  _renderPage = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2(url, headers, settings, options) {
    var secure, proxy, assets, authentication, renderContent, html, stats, getInitialState, cookies, _ref3, status, content, redirect, route, time, newCookies;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            secure = options.secure, proxy = options.proxy, assets = options.assets, authentication = options.authentication, renderContent = options.renderContent, html = options.html, stats = options.stats, getInitialState = options.getInitialState;
            cookies = headers.cookie ? cookie.parse(headers.cookie) : {};
            _context2.next = 4;
            return render(settings, {
              proxy: proxy,
              assets: assets,
              authentication: authentication,
              renderContent: renderContent,
              html: html,
              url: url,
              // Cookies for making `http` requests on server.
              cookies: cookies,
              locales: getPreferredLocales(headers),
              // Headers are used in `getInitialState()`.
              // https://github.com/catamphetamine/react-website/issues/72
              getInitialState: getInitialState,
              headers: headers
            });

          case 4:
            _ref3 = _context2.sent;
            status = _ref3.status;
            content = _ref3.content;
            redirect = _ref3.redirect;
            route = _ref3.route;
            time = _ref3.time;
            newCookies = _ref3.cookies;

            if (!redirect) {
              _context2.next = 13;
              break;
            }

            return _context2.abrupt("return", {
              redirect: redirect
            });

          case 13:
            // Report page rendering stats
            if (stats) {
              stats({
                url: url,
                route: route,
                time: time
              });
            }

            return _context2.abrupt("return", {
              cookies: newCookies,
              status: status,
              content: content
            });

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _renderPage.apply(this, arguments);
}

function respondWithError(error, response, options) {
  var _renderError = renderError(error, options),
      status = _renderError.status,
      content = _renderError.content,
      contentType = _renderError.contentType; // HTTP response status and "Content-Type"


  response.writeHead(status, {
    'Content-Type': contentType
  }); // Output the error page

  return response.end(content);
}
//# sourceMappingURL=server.js.map