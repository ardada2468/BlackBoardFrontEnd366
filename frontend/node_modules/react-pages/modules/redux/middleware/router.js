function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { UPDATE_MATCH, RESOLVE_MATCH, _RESOLVE_MATCH, getRoutesByPath, getRoutePath } from '../../router';
import { getComponentsMeta, mergeMeta, updateMeta, getCodeSplitMeta } from '../../meta/meta';
import { getLocationUrl, shouldSkipPreloadForNavigation } from '../../location';
import { ON_PAGE_LOADED_METHOD_NAME } from '../client/onPageLoaded';
import { PRELOAD_STARTED, PRELOAD_FINISHED, PRELOAD_FAILED } from '../preload/actions';
import { isInstantTransition, setInstantNavigationFlag, addInstantBack, updateInstantNavigationChainIndex, resetInstantNavigationChain } from '../client/instantNavigation';
import { isServerSidePreloaded } from '../../client/flags'; // Any events listened to here are being dispatched on client side.

export default function routerMiddleware(routes, codeSplit, onBeforeNavigate, onNavigate, reportStats, defaultMeta) {
  var startedAt;
  var previousLocation;
  var previousRouteIndices;
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (event) {
        // Skip the first pass of the initial client-side render.
        // for the case when server-side rendering is used.
        if (window._react_pages_initial_prerender) {
          return next(event);
        }

        var location = event.payload && event.payload.location;
        var routeIndices = event.payload && event.payload.routeIndices;

        switch (event.type) {
          case UPDATE_MATCH:
            // A workaround for `found` router bug:
            // https://github.com/4Catalyzer/found/issues/239
            // Skip `load` and other stuff for anchor link navigation.
            if (previousLocation && shouldSkipPreloadForNavigation(previousLocation, location)) {
              // I guess this workaround won't work with `codeSplit: true`
              // because `codeSplit` doesn't use the global `getData` loader.
              if (!codeSplit) {
                break;
              }
            } // Store `event.payload` for the future `_UPDATE_MATCH` event.


            if (!window._react_pages_router_rendered && !isServerSidePreloaded()) {
              window._react_pages_update_match_event_payload = event.payload;
            } // Measure `load` and `render` time.


            startedAt = Date.now(); // If it's an instant "Back"/"Forward" navigation
            // then navigate to the page without loading it.
            // (has been previously preloaded and is in Redux state)

            var _isInstantTransition = location.action === 'POP' && previousLocation && isInstantTransition(previousLocation, location); // Set the flag for `wasInstantNavigation()`.


            setInstantNavigationFlag(_isInstantTransition); // Indicates whether an `instantBack` `<Link/>` has been clicked.
            // (or if `goto()` has been called with `instantBack: true` option)

            var instantBack = window._react_pages_instant_back_navigation; // Update instant back navigation chain.

            if (instantBack) {
              // Stores "current" (soon to be "previous") location
              // in "instant back chain", so that if "Back" is clicked
              // then such transition could be detected as "should be instant".
              addInstantBack(location, previousLocation, routeIndices, previousRouteIndices);
            } else if (_isInstantTransition) {
              updateInstantNavigationChainIndex(location);
            } else {
              // If current transition is not "instant back" and not "instant"
              // then reset the whole "instant back" chain.
              // Only a consequitive "instant back" navigation chain
              // preserves the ability to instantly navigate "Back".
              // Once a regular navigation takes place
              // all previous "instant back" possibilities are discarded.
              resetInstantNavigationChain();
            } // Set the flag for `isInstantBackAbleNavigation()`.
            // `instantBack` is for a "forward" instant-back-able navigation.
            // `_isInstantTransition` is for a "backwards" instant-back-able navigation.


            if (instantBack || _isInstantTransition) {
              window._react_pages_is_instant_back_able_navigation = true;
            } // // `RESOLVE_MATCH` is not being emitted
            // // for the first render for some reason.
            // // https://github.com/4Catalyzer/found/issues/202
            // const isFirstRender = !previousLocation
            // if (isFirstRender) {
            // 	updateMetaTags(
            // 		routeIndices,
            // 		getState(),
            // 		{
            // 			routes,
            // 			codeSplit,
            // 			defaultMeta
            // 		}
            // 	)
            // } else {
            // 	// Show page loading indicator.
            // 	dispatch({ type: PRELOAD_STARTED })
            // }


            if (onBeforeNavigate) {
              onBeforeNavigate({
                dispatch: dispatch,
                getState: getState,
                location: event.payload.location,
                params: event.payload.params
              });
            } // Show page loading indicator.


            if (!isServerSidePreloaded() && !window._react_pages_router_rendered) {// Don't show page loading indicator
              // because it's already being shown manually.
            } else {
              // Show page loading indicator.
              dispatch({
                type: PRELOAD_STARTED
              });
            }

            break;
          // `RESOLVE_MATCH` is not being dispatched
          // for the first render for some reason.
          // https://github.com/4Catalyzer/found/issues/202
          // With server-side rendering enabled
          // initially there are two rendering passes
          // and therefore `RESOLVE_MATCH` does get dispatched
          // after the page is initialized and rendered.
          // With server-side rendering disabled
          // `RESOLVE_MATCH` does not get dispatched
          // therefore a custom `_RESOLVE_MATCH` event is
          // dispatched manually.

          case RESOLVE_MATCH:
          case _RESOLVE_MATCH:
            // A workaround for `found` router bug:
            // https://github.com/4Catalyzer/found/issues/239
            // Skip `load` and other stuff for anchor link navigation.
            if (previousLocation && shouldSkipPreloadForNavigation(previousLocation, location)) {
              // I guess this workaround won't work with `codeSplit: true`
              // because it doesn't use the global `getData` loader.
              if (!codeSplit) {
                break;
              }
            } // `routeIndices` might be `undefined` after a `<Redirect/>`
            // is made and a user clicks the "Back" button in a web browser.
            // https://github.com/4Catalyzer/found/issues/632


            if (!routeIndices) {
              throw new Error("\"".concat(event.type, "\" Redux action misses \"routeIndices\" property. This usually means that the target URL path \"").concat(location.pathname, "\" didn't match any route. ").concat(location.pathname[0] !== '/' ? 'The target URL path is missing a leading slash: correct your routes configuration to include a leading slash for "' + location.pathname + '" path. ' : '', "See the issue for more info: https://github.com/4Catalyzer/found/issues/632"));
            } // `previousLocation` is only used for "instant back" navigation.
            // Therefore it can be skipped in case of anchor link navigation.


            previousLocation = location;
            previousRouteIndices = routeIndices;

            if (!window._react_pages_router_rendered) {
              window._react_pages_router_rendered = true;
            } // Call `onLoaded`.


            if (!codeSplit) {
              var routeChain = getRoutesByPath(routeIndices, routes);
              var pageRoute = routeChain[routeChain.length - 1]; // Routes don't have `.Component` property
              // set when using `codeSplit` feature.

              var onPageLoaded = pageRoute.Component[ON_PAGE_LOADED_METHOD_NAME];

              if (onPageLoaded) {
                onPageLoaded({
                  dispatch: dispatch,
                  getState: getState,
                  location: location
                });
              }
            } // Update `<meta/>`.


            updateMetaTags(routeIndices, getState(), {
              routes: routes,
              codeSplit: codeSplit,
              defaultMeta: defaultMeta
            });

            if (onNavigate) {
              onNavigate(getLocationUrl(location), location, {
                dispatch: dispatch,
                getState: getState
              });
            } // Reset the flag for `isInstantBackAbleNavigation()`.


            window._react_pages_is_instant_back_able_navigation = false; // Report page loading time.
            // This loading time will be longer then
            // the server-side one, say, by 10 milliseconds,
            // probably because the web browser making
            // an asynchronous HTTP request is slower
            // than the Node.js server making a regular HTTP request.
            // Also this includes network latency
            // for a particular website user, etc.
            // So this `load` time doesn't actually describe
            // the server-side performance.

            if (reportStats) {
              reportStats({
                url: getLocationUrl(location),
                // Concatenated route `path` string.
                // E.g. "/user/:user_id/post/:post_id"
                route: getRoutePath(getRoutesByPath(routeIndices, routes)),
                time: {
                  loadAndRender: Date.now() - startedAt
                }
              });
            } // Hide page loading indicator.


            dispatch({
              type: PRELOAD_FINISHED
            }); // Report loading time in console for debugging.

            if (Date.now() - startedAt > 30) {
              console.log("[react-pages] \"".concat(location.pathname, "\" loaded and rendered in ").concat(Date.now() - startedAt, " ms"));
            }

            break;
        }

        return next(event);
      };
    };
  };
}

function updateMetaTags(routeIndices, state, _ref2) {
  var routes = _ref2.routes,
      codeSplit = _ref2.codeSplit,
      defaultMeta = _ref2.defaultMeta;
  var routeChain = getRoutesByPath(routeIndices, routes); // Get `<meta/>` for the route.

  var meta = codeSplit ? getCodeSplitMeta(routeChain, state) : getComponentsMeta(routeChain.map(function (_) {
    return _.Component;
  }), state);
  meta = mergeMeta(meta);
  meta = _objectSpread({}, defaultMeta, {}, meta); // Update `<meta/>`.

  updateMeta(meta);
}
//# sourceMappingURL=router.js.map