import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React from 'react';
import timer from '../../timer';
import { mergeMeta, getComponentsMeta, getCodeSplitMeta } from '../../meta/meta';
import { matchRoutes, RedirectException } from '../../router';
import createRouterElement from '../../router/server/createRouterElement'; // Returns a Promise resolving to { status, content, redirect }.
//

export default function renderOnServer(_x) {
  return _renderOnServer.apply(this, arguments);
} // One can set a `status` prop for a route
// to be returned as an Http response status code (404, etc)

function _renderOnServer() {
  _renderOnServer = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee(_ref) {
    var store, codeSplit, defaultMeta, time, preloadTimer, renderArgs, _renderArgs, routes, elements, meta;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            store = _ref.store, codeSplit = _ref.codeSplit, defaultMeta = _ref.defaultMeta;
            // Routing only takes a couple of milliseconds
            // const routingTimer = timer()
            // Profiling
            time = {};
            preloadTimer = timer();
            _context.prev = 3;
            _context.next = 6;
            return matchRoutes(store);

          case 6:
            renderArgs = _context.sent;
            _context.next = 14;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](3);

            if (!(_context.t0 instanceof RedirectException)) {
              _context.next = 13;
              break;
            }

            return _context.abrupt("return", {
              redirect: _context.t0.location
            });

          case 13:
            throw _context.t0;

          case 14:
            time.load = preloadTimer(); // Gather `<title/>` and `<meta/>` tags for this route path

            _renderArgs = renderArgs, routes = _renderArgs.routes, elements = _renderArgs.elements; // Get `<meta/>` for the route.

            meta = codeSplit ? getCodeSplitMeta(routes, store.getState()) : getComponentsMeta(elements.filter(function (_) {
              return _;
            }).map(function (_) {
              return _.type;
            }), store.getState());
            meta = mergeMeta(meta);
            meta = _objectSpread({}, defaultMeta, {}, meta); // Return HTTP status code and the rendered page

            return _context.abrupt("return", {
              // Concatenated route `path` string.
              // E.g. "/user/:user_id/post/:post_id"
              route: getRoutePath(routes),
              status: getHttpResponseStatusCodeForTheRoute(routes),
              content: createRouterElement(renderArgs),
              meta: meta,
              containerProps: {
                store: store
              },
              time: time
            });

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 9]]);
  }));
  return _renderOnServer.apply(this, arguments);
}

function getHttpResponseStatusCodeForTheRoute(matchedRoutes) {
  return matchedRoutes.reduce(function (previous, current) {
    return current && current.status || previous && current.status;
  }, null);
} // Returns a complete `path` for matched route chain.
// E.g. returns "/user/:user_id/post/:post_id"
// for matched URL "/user/1/post/123?key=value".


function getRoutePath(routes) {
  return routes // Select routes having `path` React property set.
  .filter(function (route) {
    return route.path;
  }) // Trim leading and trailing slashes (`/`)
  // from each route `path` React property.
  .map(function (route) {
    return route.path.replace(/^\//, '').replace(/\/$/, '');
  }) // Join route `path`s with slashes (`/`).
  .join('/') || '/';
}
//# sourceMappingURL=render.js.map