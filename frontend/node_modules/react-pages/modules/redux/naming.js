// Converts `UNDERSCORED_NAMES` to `camelCasedNames`.
// E.g. event `GET_USERS_ERROR` => state.`getUsersError`.
export function underscoredToCamelCase(string) {
  return string.split('_').map(function (word, i) {
    var firstLetter = word.slice(0, 1);
    var rest = word.slice(1);

    if (i === 0) {
      firstLetter = firstLetter.toLowerCase();
    } else {
      firstLetter = firstLetter.toUpperCase();
    }

    return firstLetter + rest.toLowerCase();
  }).join('');
} // Converts `namespace` and `event` into a namespaced event name

export function eventName(namespace, event) {
  return namespace ? "".concat(namespace, ": ").concat(event) : event;
}
export var DEFAULT_REDUX_EVENT_NAMING = function DEFAULT_REDUX_EVENT_NAMING(event) {
  return ["".concat(event, "_PENDING"), "".concat(event, "_SUCCESS"), "".concat(event, "_ERROR")];
};
export function generateReduxNamespace(counter) {
  return "REACT_WEBSITE_".concat(counter);
}
export function generateReduxEventName(counter) {
  return "REACT_WEBSITE_ACTION_".concat(counter);
}
export function isAutogeneratedReduxEventName(name) {
  // Matches "REACT_WEBSITE_1: REACT_WEBSITE_ACTION_2_PENDING".
  // Matches "REACT_WEBSITE_1: REACT_WEBSITE_ACTION_2".
  // Matches "SLIDESHOW: REACT_WEBSITE_ACTION_3".
  // Matches "SLIDESHOW: REACT_WEBSITE_ACTION_3_ENDING".
  return name.indexOf('REACT_WEBSITE_') >= 0;
} // Checks for `ReduxModule` autogenerated event names conflicts.

export function checkForAutogeneratedEventNameCollision(reducers) {
  var reduxModuleAutogeneratedEventNames = {};

  for (var _i = 0, _Object$keys = Object.keys(reducers); _i < _Object$keys.length; _i++) {
    var reducerName = _Object$keys[_i];

    if (reducers[reducerName]._react_pages_events) {
      var autogeneratedReduxEventNames = [];

      for (var _iterator = reducers[reducerName]._react_pages_events, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i2 >= _iterator.length) break;
          _ref = _iterator[_i2++];
        } else {
          _i2 = _iterator.next();
          if (_i2.done) break;
          _ref = _i2.value;
        }

        var _eventName = _ref;

        if (isAutogeneratedReduxEventName(_eventName)) {
          for (var _i3 = 0, _Object$keys2 = Object.keys(reduxModuleAutogeneratedEventNames); _i3 < _Object$keys2.length; _i3++) {
            var _reducerName = _Object$keys2[_i3];

            if (reduxModuleAutogeneratedEventNames[_reducerName].indexOf(_eventName) >= 0) {
              throw new Error("\"ReduxModule\" autogenerated action \"type\" collision detected for reducers \"".concat(_reducerName, "\" and \"").concat(reducerName, "\" and action \"type\" \"").concat(_eventName, "\". Specify an explicit namespace for any of the two reducers to resolve the conflict."));
            }
          }

          autogeneratedReduxEventNames.push(_eventName);
        }
      }

      reduxModuleAutogeneratedEventNames[reducerName] = autogeneratedReduxEventNames;
    }
  }
}
//# sourceMappingURL=naming.js.map