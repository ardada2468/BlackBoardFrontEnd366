export { default as foundReducer } from 'found/foundReducer';
export { default as Route } from 'found/Route';
export { default as Redirect } from 'found/Redirect';
export { default as useRouter } from 'found/useRouter';
export { default as RedirectException } from 'found/RedirectException';
import createMatchEnhancer from 'found/createMatchEnhancer';
import Matcher from 'found/Matcher';
import makeRouteConfig from 'found/makeRouteConfig';
import getStoreRenderArgs from 'found/getStoreRenderArgs';
import HttpError from 'found/HttpError';
import resolver from 'found/resolver';
import FoundActionTypes from 'found/ActionTypes';
import Actions from 'farce/Actions';
import ActionTypes from 'farce/ActionTypes';
import createHistoryEnhancer from 'farce/createHistoryEnhancer';
import createBasenameMiddleware from 'farce/createBasenameMiddleware';
import queryMiddleware from 'farce/queryMiddleware';
import { markImmediateNavigationAsInstantBack } from '../redux/client/instantNavigation';
export function createRouterStoreEnhancers(routes, createHistoryProtocol) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var middlewares = [queryMiddleware];

  if (options.basename) {
    middlewares.push(createBasenameMiddleware({
      basename: options.basename
    }));
  }

  return [createHistoryEnhancer({
    protocol: createHistoryProtocol(),
    middlewares: middlewares
  }), createMatchEnhancer( // new Matcher(hotRouteConfig(routes))
  new Matcher(routes))];
}
export function matchRoutes(store) {
  return getStoreRenderArgs({
    store: store,
    resolver: resolver,
    matchContext: {
      dispatch: store.dispatch,
      getState: store.getState
    }
  }).then(function (renderArgs) {
    if (renderArgs.error) {
      throw renderArgs.error;
    }

    return renderArgs;
  });
}
export function getRoutesByPath(routeIndices, routes) {
  var matchedRoutes = [];

  for (var _iterator = routeIndices, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var i = _ref;
    matchedRoutes.push(routes[i]);
    routes = routes[i].children;
  }

  return matchedRoutes;
}
export function getMatchedRoutes(state, routes) {
  return getRoutesByPath(state.found.match.routeIndices, routes);
}
export function getMatchedRoutesIndices(state) {
  return state.found.match.routeIndices;
}
export function getMatchedRoutesParams(state) {
  return state.found.match.routeParams;
}
export function getCurrentlyMatchedLocation(state) {
  return state.found.match.location;
}
export function getRouteParams(state) {
  return state.found.match.params;
}
export function getPreviouslyMatchedLocation(state) {
  return state.found.resolvedMatch && // state.found.resolvedMatch.location.key === undefined &&
  state.found.resolvedMatch.location;
} // Returns a complete route path for matched routes chain.
// E.g. returns "/user/:user_id/post/:post_id"
// for matched URL "/user/1/post/123?key=value".

export function getRoutePath(routes) {
  return routes // Select routes having `path` React property set.
  .filter(function (route) {
    return route.path;
  }) // Trim leading and trailing slashes (`/`)
  // from each route `path` React property.
  .map(function (route) {
    return route.path.replace(/^\//, '').replace(/\/$/, '');
  }) // Join route `path`s with slashes (`/`).
  .join('/') || '/';
}
export function convertRoutes(routes) {
  return makeRouteConfig(routes);
}
export function initializeRouter(store) {
  store.dispatch(Actions.init());
}
export var redirect = Actions.replace;

var _goto = function _goto(location) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  markImmediateNavigationAsInstantBack(options.instantBack);
  return Actions.push(location);
};

export { _goto as goto };
export var REDIRECT_ACTION_TYPE = ActionTypes.REPLACE;
export var GOTO_ACTION_TYPE = ActionTypes.PUSH;
export function goBack() {
  return Actions.go(-1);
}
export function goForward() {
  return Actions.go(1);
}
export function pushLocation(location, options) {
  window._react_pages_skip_preload_update_location = true;
  return _goto(location, options);
}
export function replaceLocation(location) {
  window._react_pages_skip_preload_update_location = true;
  return redirect(location);
}
export var UPDATE_MATCH = FoundActionTypes.UPDATE_MATCH;
export var RESOLVE_MATCH = FoundActionTypes.RESOLVE_MATCH;
export var _RESOLVE_MATCH = '@@react-pages/RESOLVE_MATCH';
//# sourceMappingURL=index.js.map