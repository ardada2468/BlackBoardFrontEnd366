import _awaitAsyncGenerator from "@babel/runtime/helpers/esm/awaitAsyncGenerator";
import _wrapAsyncGenerator from "@babel/runtime/helpers/esm/wrapAsyncGenerator";
import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import HttpError from './HttpError';

function foldElements(elementsRaw, routeIndices) {
  const elements = [];

  for (const routeIndex of routeIndices) {
    if (typeof routeIndex === 'object') {
      // Reshape the next elements in the elements array to match the nested
      // tree structure corresponding to the route groups.
      const groupElements = {};
      Object.entries(routeIndex).forEach(([groupName, groupRouteIndices]) => {
        groupElements[groupName] = foldElements(elementsRaw, groupRouteIndices);
      });
      elements.push(groupElements);
    } else {
      // We intentionally modify elementsRaw, to make it easier to recursively
      // handle groups.
      elements.push(elementsRaw.shift());
    }
  }

  return elements;
}

export default function resolveRenderArgs(_x, _x2) {
  return _resolveRenderArgs.apply(this, arguments);
}

function _resolveRenderArgs() {
  _resolveRenderArgs = _wrapAsyncGenerator(function* (router, {
    match,
    matchContext,
    resolver
  }) {
    const routes = router.matcher.getRoutes(match);
    const augmentedMatch = Object.assign({}, match, {
      routes,
      router,
      // Convenience access for route components.
      context: matchContext
    });

    if (!routes) {
      // Immediately render a "not found" error if no routes matched.
      yield Object.assign({}, augmentedMatch, {
        error: new HttpError(404)
      });
      return;
    }

    try {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;

      var _iteratorError;

      try {
        for (var _iterator = _asyncIterator(resolver.resolveElements(augmentedMatch)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
          const elements = _value;
          yield Object.assign({}, augmentedMatch, {
            elements: elements && foldElements([...elements], match.routeIndices)
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            yield _awaitAsyncGenerator(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } catch (e) {
      if (e.isFoundHttpError) {
        yield Object.assign({}, augmentedMatch, {
          error: e
        });
        return;
      }

      throw e;
    }
  });
  return _resolveRenderArgs.apply(this, arguments);
}