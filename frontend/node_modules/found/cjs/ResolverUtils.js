"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.checkResolved = checkResolved;
exports.isResolved = isResolved;
exports.accumulateRouteValues = accumulateRouteValues;
exports.getRouteMatches = getRouteMatches;
exports.getRouteValue = getRouteValue;
exports.getRouteValues = getRouteValues;
exports.getComponents = getComponents;

var _setImmediate2 = _interopRequireDefault(require("core-js-pure/stable/set-immediate.js"));

var _isPromise = _interopRequireDefault(require("is-promise"));

var _warning = _interopRequireDefault(require("warning"));

const UNRESOLVED = {};

function checkResolved(value) {
  if (!(0, _isPromise.default)(value)) {
    return value;
  }

  return Promise.race([value, new Promise(resolve => {
    (0, _setImmediate2.default)(resolve, UNRESOLVED);
  })]);
}

function isResolved(value) {
  return value !== UNRESOLVED;
}

function accumulateRouteValuesImpl(routeValues, routeIndices, callback, initialValue) {
  const accumulated = [];
  let value = initialValue;

  for (const routeIndex of routeIndices) {
    if (typeof routeIndex === 'object') {
      // eslint-disable-next-line no-loop-func
      Object.values(routeIndex).forEach(groupRouteIndices => {
        accumulated.push(...accumulateRouteValuesImpl(routeValues, groupRouteIndices, callback, value));
      });
    } else {
      value = callback(value, routeValues.shift());
      accumulated.push(value);
    }
  }

  return accumulated;
}

function accumulateRouteValues(routeValues, routeIndices, callback, initialValue) {
  return accumulateRouteValuesImpl([...routeValues], routeIndices, callback, initialValue);
}

function getRouteMatches(match) {
  return match.routes.map((route, i) => Object.assign({}, match, {
    route,
    routeParams: match.routeParams[i]
  }));
}

function getRouteValue(match, getGetter, getValue) {
  const {
    route
  } = match;
  const getter = getGetter(route);
  return getter ? getter.call(route, match) : getValue(route);
} // This is a little more versatile than if we only passed in keys.


function getRouteValues(routeMatches, getGetter, getValue) {
  return routeMatches.map(match => getRouteValue(match, getGetter, getValue));
}

function getRouteGetComponent(route) {
  return route.getComponent;
}

function getRouteComponent(route) {
  if (process.env.NODE_ENV !== "production" && route.component) {
    process.env.NODE_ENV !== "production" ? (0, _warning.default)(route.Component, 'Route with `component` property `%s` has no `Component` property. The expected property for the route component is `Component`.', route.component.displayName || route.component.name) : void 0;
  }

  return route.Component;
} // This should be common to most resolvers, so make it available here.


function getComponents(routeMatches) {
  return getRouteValues(routeMatches, getRouteGetComponent, getRouteComponent);
}