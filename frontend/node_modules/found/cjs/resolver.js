"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _isPromise = _interopRequireDefault(require("is-promise"));

var _ResolverUtils = require("./ResolverUtils");

var _createElements = _interopRequireDefault(require("./createElements"));

function getRouteGetData(route) {
  return route.getData;
}

function getRouteData(route) {
  return route.data;
}

var _default = {
  resolveElements(match) {
    var _this = this;

    return (0, _wrapAsyncGenerator2.default)(function* () {
      const routeMatches = (0, _ResolverUtils.getRouteMatches)(match);
      const Components = (0, _ResolverUtils.getComponents)(routeMatches);

      const data = _this.getData(match, routeMatches);

      const earlyComponents = Components.some(_isPromise.default) ? yield (0, _awaitAsyncGenerator2.default)(Promise.all(Components.map(_ResolverUtils.checkResolved))) : Components;
      const earlyData = data.some(_isPromise.default) ? yield (0, _awaitAsyncGenerator2.default)(Promise.all(data.map(_ResolverUtils.checkResolved))) : data;
      let fetchedComponents;
      let fetchedData;

      if (!earlyComponents.every(_ResolverUtils.isResolved) || !earlyData.every(_ResolverUtils.isResolved)) {
        const pendingElements = (0, _createElements.default)(routeMatches, earlyComponents, earlyData);
        yield pendingElements.every(element => element !== undefined) ? pendingElements : undefined;
        fetchedComponents = yield (0, _awaitAsyncGenerator2.default)(Promise.all(Components));
        fetchedData = yield (0, _awaitAsyncGenerator2.default)(Promise.all(data));
      } else {
        fetchedComponents = earlyComponents;
        fetchedData = earlyData;
      }

      yield (0, _createElements.default)(routeMatches, fetchedComponents, fetchedData);
    })();
  },

  /**
   * Generate route data according to their getters, respecting the order of
   * promises per the `defer` flag on routes.
   */
  getData(match, routeMatches) {
    return (0, _ResolverUtils.accumulateRouteValues)(routeMatches, match.routeIndices, ({
      ancestorRouteData,
      prevParentPromise
    }, routeMatch) => {
      // For a deferred route, the parent promise is the previous promise.
      // Otherwise, it's the previous parent promise.
      const parentPromise = routeMatch.route.defer ? Promise.all(ancestorRouteData) : prevParentPromise; // If there is a parent promise, execute after it resolves.

      const routeData = parentPromise ? parentPromise.then(() => (0, _ResolverUtils.getRouteValue)(routeMatch, getRouteGetData, getRouteData)) : (0, _ResolverUtils.getRouteValue)(routeMatch, getRouteGetData, getRouteData);
      return {
        routeData,
        ancestorRouteData: [...ancestorRouteData, routeData],
        prevParentPromise: parentPromise
      };
    }, {
      routeData: null,
      ancestorRouteData: [],
      prevParentPromise: null
    }).map(({
      routeData
    }) => routeData);
  }

};
exports.default = _default;
module.exports = exports.default;