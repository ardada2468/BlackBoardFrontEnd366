"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = resolveRenderArgs;

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _HttpError = _interopRequireDefault(require("./HttpError"));

function foldElements(elementsRaw, routeIndices) {
  const elements = [];

  for (const routeIndex of routeIndices) {
    if (typeof routeIndex === 'object') {
      // Reshape the next elements in the elements array to match the nested
      // tree structure corresponding to the route groups.
      const groupElements = {};
      Object.entries(routeIndex).forEach(([groupName, groupRouteIndices]) => {
        groupElements[groupName] = foldElements(elementsRaw, groupRouteIndices);
      });
      elements.push(groupElements);
    } else {
      // We intentionally modify elementsRaw, to make it easier to recursively
      // handle groups.
      elements.push(elementsRaw.shift());
    }
  }

  return elements;
}

function resolveRenderArgs(_x, _x2) {
  return _resolveRenderArgs.apply(this, arguments);
}

function _resolveRenderArgs() {
  _resolveRenderArgs = (0, _wrapAsyncGenerator2.default)(function* (router, {
    match,
    matchContext,
    resolver
  }) {
    const routes = router.matcher.getRoutes(match);
    const augmentedMatch = Object.assign({}, match, {
      routes,
      router,
      // Convenience access for route components.
      context: matchContext
    });

    if (!routes) {
      // Immediately render a "not found" error if no routes matched.
      yield Object.assign({}, augmentedMatch, {
        error: new _HttpError.default(404)
      });
      return;
    }

    try {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;

      var _iteratorError;

      try {
        for (var _iterator = (0, _asyncIterator2.default)(resolver.resolveElements(augmentedMatch)), _step, _value; _step = yield (0, _awaitAsyncGenerator2.default)(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield (0, _awaitAsyncGenerator2.default)(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
          const elements = _value;
          yield Object.assign({}, augmentedMatch, {
            elements: elements && foldElements([...elements], match.routeIndices)
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            yield (0, _awaitAsyncGenerator2.default)(_iterator.return());
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } catch (e) {
      if (e.isFoundHttpError) {
        yield Object.assign({}, augmentedMatch, {
          error: e
        });
        return;
      }

      throw e;
    }
  });
  return _resolveRenderArgs.apply(this, arguments);
}

module.exports = exports.default;