"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = createBaseRouter;

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _mapContextToProps = _interopRequireDefault(require("@restart/context/mapContextToProps"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactRedux = require("react-redux");

var _reactStaticContainer = _interopRequireDefault(require("react-static-container"));

var _warning = _interopRequireDefault(require("warning"));

var _RouterContext = _interopRequireDefault(require("./RouterContext"));

var _createRender = _interopRequireDefault(require("./createRender"));

var _createStoreRouterObject = _interopRequireDefault(require("./createStoreRouterObject"));

var _resolveRenderArgs = _interopRequireDefault(require("./resolveRenderArgs"));

function createBaseRouter({
  renderPending,
  renderReady,
  renderError,
  render = (0, _createRender.default)({
    renderPending,
    renderReady,
    renderError
  })
}) {
  const propTypes = {
    store: _propTypes.default.object.isRequired,
    match: _propTypes.default.object.isRequired,
    resolvedMatch: _propTypes.default.object.isRequired,
    matchContext: _propTypes.default.any,
    resolver: _propTypes.default.shape({
      resolveElements: _propTypes.default.func.isRequired
    }).isRequired,
    onResolveMatch: _propTypes.default.func.isRequired,
    initialRenderArgs: _propTypes.default.object
  };

  class BaseRouter extends _react.default.Component {
    constructor(props) {
      super(props);
      const {
        store,
        match,
        matchContext,
        resolver,
        initialRenderArgs
      } = props;
      this.router = (0, _createStoreRouterObject.default)(store);
      this.state = {
        isInitialRender: true,
        match,
        matchContext,
        resolver,
        iteration: 0,
        routerContext: {
          router: this.router,
          match: initialRenderArgs || null
        },
        element: initialRenderArgs ? render(initialRenderArgs) : null
      };
      this.mounted = true;
      this.lastIteration = 0;
      this.pendingResolvedMatch = false;
    } // We use componentDidMount and componentDidUpdate to resolve the match if
    //  needed because element resolution is asynchronous anyway, and this lets
    //  us not worry about setState not being available in the constructor, or
    //  about having to pass around nextProps.


    componentDidMount() {
      if (!this.props.initialRenderArgs) {
        this.resolveMatch();
      }

      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */

        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          process.env.NODE_ENV !== "production" ? (0, _warning.default)(!window.__FOUND_REPLACE_ROUTE_CONFIG__, 'Replacing existing hot reloading hook. Do not render more than one router instance when using hot reloading.') : void 0;
          window.__FOUND_REPLACE_ROUTE_CONFIG__ = this.router.replaceRouteConfig;
        }
        /* eslint-enable no-underscore-dangle */

        /* eslint-env browser: false */

      }
    }

    static getDerivedStateFromProps({
      match,
      resolver,
      matchContext
    }, state) {
      if (state.isInitialRender) {
        return {
          isInitialRender: false
        };
      }

      if (match !== state.match || resolver !== state.resolver || !(0, _isEqual.default)(matchContext, state.matchContext)) {
        return {
          match,
          resolver,
          matchContext,
          iteration: state.iteration + 1
        };
      }

      return null;
    }

    componentDidUpdate() {
      if (this.state.iteration > this.lastIteration) {
        this.lastIteration = this.state.iteration;
        this.resolveMatch();
      }
    }

    componentWillUnmount() {
      this.mounted = false;

      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */

        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          delete window.__FOUND_REPLACE_ROUTE_CONFIG__;
        }
        /* eslint-enable no-underscore-dangle */

        /* eslint-env browser: false */

      }
    }

    async resolveMatch() {
      const pendingIteration = this.lastIteration;
      const pendingMatch = this.props.match;

      try {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;

        var _iteratorError;

        try {
          for (var _iterator = (0, _asyncIterator2.default)((0, _resolveRenderArgs.default)(this.router, this.props)), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
            const renderArgs = _value;

            // Don't do anything if we're resolving an outdated match.
            if (!this.mounted || this.lastIteration !== pendingIteration) {
              return;
            } // If we're about to mark the match resolved, delay the rerender
            //  until we do so.


            this.pendingResolvedMatch = !!((renderArgs.elements || renderArgs.error) && this.props.resolvedMatch !== pendingMatch);
            this.setState({
              routerContext: {
                router: this.router,
                match: renderArgs
              },
              element: render(renderArgs)
            });

            if (this.pendingResolvedMatch) {
              // If this is a new match, update the store, so we can rerender at
              //  the same time as all of the links and other components
              //  connected to the router state.
              this.pendingResolvedMatch = false;
              this.props.onResolveMatch(pendingMatch);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              await _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } catch (e) {
        if (!this.mounted || this.lastIteration !== pendingIteration) {
          return;
        }

        if (e.isFoundRedirectException) {
          this.router.replace(e.location);
          return;
        }
        /* istanbul ignore next: paranoid guard */


        throw e;
      }
    }

    render() {
      const {
        iteration,
        routerContext,
        element
      } = this.state; // Don't rerender synchronously if we have another rerender coming.

      return /*#__PURE__*/_react.default.createElement(_reactStaticContainer.default, {
        shouldUpdate: this.lastIteration === iteration && !this.pendingResolvedMatch
      }, /*#__PURE__*/_react.default.createElement(_RouterContext.default.Provider, {
        value: routerContext
      }, element));
    }

  }

  BaseRouter.propTypes = propTypes; // FIXME: For some reason, using contextType doesn't work here.

  return (0, _mapContextToProps.default)({
    consumers: _reactRedux.ReactReduxContext,
    mapToProps: ({
      store
    }) => ({
      store
    }),
    displayName: 'withStore(BaseRouter)'
  }, BaseRouter);
}

module.exports = exports.default;